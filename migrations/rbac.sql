-- CUSTOM TYPES
CREATE TYPE public.app_permission AS ENUM ('members.select', 'members.update', 'members.insert', 'user_roles.select', 'user_roles.update', 'user_roles.insert');
CREATE TYPE public.app_role AS ENUM ('admin', 'member', 'applicant');

-- USER ROLES
CREATE TABLE public.user_roles (
  id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id   UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role      app_role NOT NULL,
  UNIQUE (user_id, role)
);
COMMENT ON TABLE public.user_roles IS 'Application roles for each user.';

-- USER ROLES RLS POLICIES
CREATE POLICY "Allow authorized select access"
ON "public"."user_roles"
FOR SELECT TO authenticated USING (
  (SELECT authorize('user_roles.select'))
);

CREATE POLICY "Allow authorized update access"
ON "public"."user_roles"
FOR UPDATE TO authenticated USING (
  (SELECT authorize('user_roles.update'))
);

CREATE POLICY "Allow authorized insert access"
ON "public"."user_roles"
FOR INSERT TO authenticated WITH CHECK (
  (SELECT authorize('user_roles.insert'))
);

-- ROLE PERMISSIONS
CREATE TABLE public.role_permissions (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role        app_role NOT NULL,
  permission  app_permission NOT NULL,
  UNIQUE (role, permission)
);
COMMENT ON TABLE public.role_permissions IS 'Application permissions for each role.';
INSERT INTO public.role_permissions (role, permission)
VALUES  ('admin', 'members.select'),  
        ('admin', 'members.update'),
        ('admin', 'members.insert'),
        ('admin', 'user_roles.select'),
        ('admin', 'user_roles.update'),
        ('admin', 'user_roles.insert');

-- CUSTOM CLAIMS
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
  DECLARE
    claims jsonb;
    user_role public.app_role;
  BEGIN
    -- Fetch the user role in the user_roles table
    SELECT role INTO user_role FROM public.user_roles WHERE user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    IF user_role IS NOT NULL THEN
      -- Set the claim
      claims := JSONB_SET(claims, '{user_role}', TO_JSONB(user_role));
    ELSE
      claims := JSONB_SET(claims, '{user_role}', 'null');
    END IF;

    -- Update the 'claims' object in the original event
    event := JSONB_SET(event, '{claims}', claims);

    -- Return the modified or original event
    RETURN event;
  END;
$$;

GRANT USAGE ON SCHEMA public TO supabase_auth_admin;

GRANT EXECUTE
  ON FUNCTION public.custom_access_token_hook
  TO supabase_auth_admin;

REVOKE EXECUTE
  ON FUNCTION public.custom_access_token_hook
  FROM authenticated, anon, public;

GRANT ALL
  ON TABLE public.user_roles
TO supabase_auth_admin;

REVOKE ALL
  ON TABLE public.user_roles
  FROM authenticated, anon, public;

CREATE POLICY "Allow auth admin to read user roles" ON public.user_roles
AS PERMISSIVE FOR SELECT
TO supabase_auth_admin
USING (TRUE);

-- RLS AUTHORIZE
CREATE OR REPLACE FUNCTION public.authorize(
  requested_permission app_permission
)
RETURNS boolean AS $$
DECLARE
  bind_permissions int;
  user_role public.app_role;
BEGIN
  SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;

  SELECT COUNT(*)
  INTO bind_permissions
  FROM public.role_permissions
  WHERE role_permissions.permission = requested_permission
    AND role_permissions.role = user_role;

  RETURN bind_permissions > 0;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';
